<!DOCTYPE html>
<html>
<head>
  
<title>Flenagan from 8_2 to</title>
</head>
<body>

<script type="text/javascript">
/* 8.3.2 Списки аргументов переменной длины
обьект Arguments - позволяет извдекать переданые функции по номерам, а не по именам.
След. код показывает была ли функция вызвана с правильным числом аргументов*/
function iio(x, y, z) {
  //Сначала проверяем правильно ли количество переданых елементов
  if(arguments.length != 3){
    throw new Error ("Функция F  вызвана с " + arguments.length + " а не с 3");
  }
  //теперь само тело функции
}
//=======================================================================
/*Следующая функция принимает любое число аргументов и возвращает найбольшее, аналогично функции Math.max()*/
function max(){
  var m = number.NEGATIVE_INFINITY;
  //икл по всем аргументам, поиск и сохранение найбольшего из них
  for(var i = 0; i < arguments.length; i++)
    if(arguments[i] > max) max = arguments[i];
  // рнуть найбольшее значение
  return max;
  
}
var largest = max(1, 2, 100, 34, 45);
document.write(largest);
//===============================================================
// Возвращает сумму елементов массива "а"
// все елементы массива должны быть числовыми, при это null and underfinded игнорируются
function sum(a){
  if(isArrayLike(a)){
    var total = 0;
    for(var i = 0; i < a.length; i++){ // цикл по всем елементам
      var element = a[i];
      if(element === null) continue;
      if(isFinite(element)) total += element;
      else throw new Error ("sum(): все елементы должны быть числами");

    }
    return total;
  }
  else throw new Error ("sum(): аргумент должен быть массивом")
}
//=======================================
function flexisum(a){
var total = 0;
for(var i = 0; i < arguments.length; i++){
  var element = arguments[i], n;
  if(element === null) continue; //игнорировать нулы underfined
  if(isArray(element)) //если аргумент массив
    n = flexisum.apply(this, element); //вычислить сумму рекурсивно
  else if(typeof element === function() // иначе если это функция
    n = Number(element));
  else n = Number(element);
  if(isNaN(n)) throw new Error("flexisum(): невозможно преобразовать " + element + " в число");
  total += n; //иначе прибавить к тотал
}
return total;
}
//================================================================================
// 8_5 ФУНКЦИИ как пространства имен
function mymodule(){ //здесь находится реализация модуля
//любые переменные превратятся в локальные и не будут засорять пространство

}
mymodule(); //но не забудьте вызвать функцию
/*Такой способ записание выражений используется настолько часто что превратился в типичный прием*/
//================================================================================
//8_5 ЗАМЫКАНИЯ
var uniqueInteger = (function(){ //определение и вызов
  var counter = 0; //частное значение для функции ниже
  return function(){
    return counter++;
  };
alert(uniqueInteger);
}());
//==============================================================================
//СВОЙСТВО И МЕТОДЫ ФУНКЦИЙ И КОНСТРУКТОРОВ
//Замещает метод М обьекто о , версией метода которая регитрирует сообщения до и после вызова оригинального //метода
function trace(o, m){
  var original = o[m]; // сохранить оригинальный метод в замыкании
  o[m] = function(){    // определить новый метод
console.log(new Date(), "Entering: ", m);
var result = origin.apply(this, arguments); //вызвать оригинал
console.log(new Date(), "Exiting: ", m);   // записать сообщение
return result;
  };}
// Эта функция trace() принимает обьект и имя метода. Она замещает указаный метод новым методом, обёртывая его новой функциональность. monkey-patching
//================================================================================================
// method bind()
function f(y){ return this.x + y;} //функция которую требуется привязать
var o = { x : 1};   // обьект к которому выполняется привязка
var g = f.bind(o); // g(x) вызовет o.f(x)
g(2); // => 3
//-------------
function f(y, z){return this.x + y + z;}
var g = f.bind({x:1}, 2); // связывает this  и у
g(3); // this.x связан с 1, у связан с 2, а я передается 3
//==============================================================================
//ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ
// Найти среднее значение и стандартное отклонение для этих значений
var data[1,1,3,5,5];
var total = 0;
for(var i = 0; i < data.length; i++) total += data[i];
var mean = total/data.length; // среднее значение равно 3
// чтобы найти стандартное отклонение нужно вычислить сумму квадратов отклонений елементов от среднего
total = 0;
for(var i = 0; i < data.length; i++){
var deviation = data[i] - mean;
total += deviation * deviation;
}
var stddev = Math.sqrt(total/(data.length - 1)); // стандартное отклонение равно 2
//================================================================
// ФУНКЦИИ ВЫСШЕГО ПОРЯДКА
//вОЗВРАЩАЕТ ФУНКЦИЮ КОТОРАЯ ПРИНИМАЕТ МАССИВ В ВИДЕ АРГУМЕНТА, применяет функцию f для 
// каждого елемента и возвращает массив
function mapper(f){
return function(a){map(a, f); };
}
var increment = function(x){return x + 1;};
var increment = mapper(increment);
increment([1,2,3]) //=> [2,3,4]

//Возвращает найбольший делитель используя алгоритм Евклида
function gcd(a, b){
  var t;
  if( a < b) t = b, b = a, a = t;
  while(b != 0) t = b, b = a%b, a = t; // это алгоритм поиска НОД
  return a;
}
var gcdmemo = memoize(gcd);
gcdmemo(23, 25); // вывод значения
</script>


</body>
</html>

